# 32、最长有效括号
难度：hard

题目网址：https://leetcode.cn/problems/longest-valid-parentheses/

代码语言：cpp

## 题解
### 方法一：栈
思路来源：[【LeetCode 每日一题】32. 最长有效括号 | 手写图解版思路 + 代码讲解](https://www.bilibili.com/video/BV1R44y1p7J7/?spm_id_from=333.337.search-card.all.click&vd_source=5a9892c5685e5b7e1d5cbd33baa8869e)

首先，若要使括号子串有效，需要满足两个条件：

* 该子串任意前缀的左括号数量大于等于右括号
* 该子串的左括号数量等于右括号数量

因此对于一个字符串，可以找到若干个“第一次右括号数量大于左括号”的位置下标，并以此下标作为分割点把原字符串分割成多段，分割之后分别求这几段子串最长的有效括号，下面给出两个例子：
> eg1.`)()())`的两个分割点下标依次是下标0和下标5，分割后得到一个子串：`()()`，如何求这个子串的最长有效括号？只需要依次遍历，遇到左括号即入栈，遇到右括号则弹出栈顶元素，若弹出之后栈为空，说明整个子串都是有效括号，
> 否则，子串的长度是当前遍历到的右括号下标减去弹出后栈顶元素的下标。
>
> eg2.`(()))(()`的一个分割点下标是4，分割后得到的第一个子串是`(())`，另一个子串是`(()`

接下来，我们把寻找分割点的过程融合到遍历过程中，由于分割点本质是下一个括号子串的起点位置的前一个位置，因此在遍历过程中，可以维护一个start变量，初始化为-1，具体代码如下，代码后会给出例子：

C++

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        int ans = 0;
        for (int i = 0, start = -1; i < s.length(); i ++ ) {
            if (s[i] == '(') st.push(i);
            else {
                if (!st.empty()) {
                    st.pop();
                    if (!st.empty()) {
                        ans = max(ans, i - st.top());
                    }
                    else ans = max(ans, i - start);
                }
                else start = i;
            }
        }
        return ans;
    }
};
```

依旧以`(()))(()`为例子进行解释，遍历这个字符串：

* i=0,start=-1时，元素为左括号，直接将其下标入栈，此时栈中元素为`[0]`
* i=1,start=-1时，元素为左括号，直接将其下标入栈，此时栈中元素为`[0,1]`
* i=2,start=-1时，元素为右括号，弹出栈顶元素，此时栈中元素为`[0]`，此时栈依然不空，故更新`ans = max(ans, i - st.top()) = max(0, 2 - 0) = 2`
* i=3,start=-1时，元素为右括号，弹出栈顶元素，此时栈空，说明这段子串从起点开始均为有效子串，故更新`ans = max(ans, i - start)) = max(2, 3 - (-1)) = 4`
* i=4,start=-1时，元素为右括号，此时栈空，**说明找到了分割点**，因此将start更新为4，表示下一段子串的起点的前一个位置
* i=5,start=4时，元素为左括号，入栈，栈为`[5]`
* i=6,start=4时，元素为左括号，入栈，栈为`[5，6]`
* i=7,start=4时，元素为右括号，弹出栈顶元素，此时栈中元素为`[5]`，故更新`ans = max(ans, i - st.top()) = max(4, 7 - 5) = 4`
